# [设计模式](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)

- 解决实际问题的解决方案

## 单例模式

- 保证一个类只有一个实例，并提供一个访问它的全局访问方法
- `主要解决`一个全局使用的类被频繁创建和销毁的场景

## 工厂模式

- 定义一个创建对象的接口，让其子类自己决定实例化哪个工厂类，工厂模式使创建过程延迟到子类进行
- 创建对象时不对客户端暴露创建逻辑，通过一个共同的方法来创建对象
- 简单工厂模式：把创建同一类对象的逻辑封装到一个函数上
- 工厂方法模式：把生产产品的方法封装到工厂函数的 prototype 上
- 抽象工厂模式：生产工厂的函数
- `主要解决`对创建对象的细节进行封装

## 观察者模式

- 定义对象间的一种一对多的依赖关系，当一个对象状态发生变化时，在`被观察者`身上触发通知，让所有观察者触发监听
- 只能精确地通知到对应的对象，如果有多个不同任务需要创建多个不同任务的对象作为`被观察者`（目标对象）
- 举例
  - 天气预报（气象台、用户）
  - 股票监控（股票交易所、投资者）
  - 用户动态关注（用户 A、用户 B）

## 发布订阅模式

- 把想订阅的事件注册到调度中心，`发布者`触发`调度中心`上相关`主题`方法，进而通知各个`订阅者`
- 发布者和订阅者之间是解耦的关系
- 举例
  - 报纸订阅（报社、邮局、读者）
  - 某社交栏目关注（用户 A、社交平台、用户 B）

## 策略模式

- 定义一系列的算法，把他们一个一个封装起来，并使他们可以相互替换
- 通过 key-value 选择的方式 来代替 if-else 的写法
- `主要解决`在有多种算法相似的情况下，使用 if-else 所带来的复杂和难以维护

## 备忘录模式

- 在不破坏封装的前提下，捕获对象状态变化，并在对象之外保存这个状态
- `主要解决`在以后将对象进行恢复到原先保存的状态

## 装饰器模式

- 在不破坏类或者不使用类继承的情况下，增强和扩展类的功能。
- es6 中的装饰器只能对类以及类的属性和方法使用，不能对函数使用，因为函数定义存在变量提升。
- `应用场景`：数据上报
- `主要解决`：在不想增加很多子类的情况下扩展类
