## 介绍一下 TCP 三次握手

- 第一步，客户端发送`SYN包`（SYN=1，seq=x），进入请求连接（SYN_SEND）状态
- 第二步，服务端接收请求，并响应`确认包`（SYN=1，ACK=1，seq=y，ack=x+1），进入`半连接`状态（SYN_CRVD）
- 第三步，客户端接收确认包，再发送个`确认包`（ACK=1，seq=x+1，ack=y+1）进入`连接`（ESTABLISHED）状态，服务端接收到确认包后也进入`连接`（ESTABLISHED）状态

## 为什么 TCP 握手需要三次

- 避免`重复连接`，防止已失效的连接重新建立，减少资源浪费
- 确认收发双方的`收发能力`

## 介绍一下 TCP 四次挥手

- 第一步，发送方`发送终止包`（FIN=1，seq=u），进入`终止等待1`状态（FIN-WAIT1）
- 第二步，接收方接收后，`发送确认包`（ACK=1，seq=v，ack=u+1），接收方进入`关闭等待`状态（CLOSE-WAIT），发送方接收到确认包后进入`终止等待2`状态（FIN-WAIT2）
- 第三步，此时发送方处于`半关闭`状态，发送方还能继续接收接收方的消息，当接收方`发送终止包`（FIN=1，ACK=1，ack=u+1，seq=w），进入`最后确认`状态（LAST-ACK）
- 第四步，发送方`发送确认包`（ACK=1，seq=u+1，ack=w+1）进入`时间等待`状态（TIME-WAIT），等待 2MSL（最长报文段寿命）后进入`关闭`（CLOSED）状态，接收方接收到确认包后也进入`关闭`（CLOSED）状态
- 完成四次挥手断开连接

## 为什么 TCP 挥手需要四次

- `避免数据丢失`，保证等数据完全接收后再关闭连接
- 在挥手的最后，发送方再等 `2msl`（最长报文寿命）再进入关闭状态，避免 ACK 确认包没有被正常接收

### 为什么要等 2msl

- 2msl 最长报文寿命，是一个消息报文的往返时间
- 确保 ACK 确认包能被正确接收到

## UDP 和 TCP 的区别

- TCP 和 UDP 都是传输层协议
- TCP 面向`连接可靠`，UDP 不需要连接而且不可靠，丢了就丢了不会重发
- TCP 只能做`一对一`传输，UDP 可以做一对多传输
- TCP 包头 20 `字节`，UDP 8 字节
- TCP 面向`字节流`存在粘包问题，UDP 面向报文传输不存在粘包问题
- TCP 更适合安全和`数据完整`要求比较高的场景，比如发送文件发送邮件等；UDP 更适合`实时性`要求比较高的场景，比如打电话、实时游戏等等

### TCP 为什么连接

- 连接是为了确认双方的存在，并且都有收发数据的能力

### TCP 保证可靠的手段有哪些

- TCP 的保证可靠主要解决四个问题：丢包、重复、乱序、误码
- 手段
  - 序列号
  - 校验和
  - 确认应答
  - 超时重传
    - 发送端开启定时器，等待 ack 确认包
  - 流量控制
    - 通过滑动窗口机制，动态调整双方的发送窗口和接收窗口大小，控制发送双方的速率，防止传输过快分组丢失
    - 通过 tcp 报文上的窗口字段传递信息
  - 拥塞控制
    - 定义
      - 拥塞窗口(cwnd)是发送方维护的一个状态变量，它会根据网路拥堵情况动态调节。
    - 算法
      - 慢启动
      - 拥塞避免
      - 快重传
      - 快恢复
    - 参考
      - [一文带你搞定 TCP 拥塞控制](https://cloud.tencent.com/developer/article/1920081)

### TCP 粘包解决方案

- 固定数据包大小
- 给数据包头部添加长度字段（content-type:length）
- 通过特殊字符串标识边界（http 报文就是通过换行符来标识数据边界）

## 短轮循、长轮循、SSE 和 Websocket 的区别

- `短轮循`每隔一段时间发送 http 请求到服务器，服务器不管有没数据更新都直接响应回去
- `长轮循`每隔一段时间发送 http 请求到服务器，服务器判断有数据更新就响应，没有则暂时挂起请求
- `服务器推送SSE`利用 html5 新特性 EventSource 从服务器给客户端发送消息
- `websocket`在客户端和服务器实现真正的双向通信，先进行一次 http 协议握手，握手成功后，数据走 tcp 传输，与 http 无关了
  - 支持传输字符串和二进制数据（blob 对象、arrayBuffer 对象）

### websocket 心跳

- 原因：在一些未知的情况下网络断开，没有触发 onClose 事件（没有收到服务器的关闭帧，浏览器会长时间保持连接状态），导致资源浪费问题
- 目的：检查客户端和服务器是否处于在线（连接）状态
- 实现：定时发送 ping pong 数据帧
  - 浏览器支持自动响应 pong 包，但不支持自动发送 ping 数据包，需要自己实现
  - 浏览器定时发送 ping 数据，服务器响应 pong 数据
    - 两个定时器：一个发送 ping 包，一个检查是否超时
- 为什么不基于 tcp 的心跳机制
  - 定时周期太长，tcp keep-alive 时长默认 7200s（2h），即每次发送心跳的周期；如果连续没有收到对方的确认（ack）包，才会通知应用层断开连接，这样会有很多不确定性因素

### websocket 重连

- 原因：心跳响应超时、连接明确断开、连接没断但不可用
- 场景：服务器负载过高无法响应、设备切换网络、链路中间路由不可用（运营商故障）
- 实现：
  - 确定何时重连
    - 连续发送`心跳超时`（3 次），自动重连、提示用户断线（手动重连）
      - 不建议立即重连，立即重连会造成大量并发请求，严重消耗网络带宽，对服务器也会造成雪崩效应，而且大概率立即重连也会失败
      - 建议相隔一定时间后进行重连，并且采用`指数退避算法`（exponential backoff）（重试次数越多，时间间隔越长）避免频繁连接，减轻服务器压力
    - 监听`网络状态`变化，由 offline 变为 online 触发重连机制
      - navigator.onLine
      - window.addEventListener online offline
      - navigator.connection（下行速度、估计速度类型、往返时间）（兼容性差）
  - 断开旧连接
  - 发起新连接

## 介绍一下网络七层协议

- 物理层：通过不同信号（光、电磁波）来传输比特流
- 数据链路层：对比特流进行封装，解决数据在一个网络中如何传输的问题
- 网络层：解决数据在不同网络之间传输的问题，以及路由分发寻址的问题，ip 协议
- 传输层：解决数据如何端到端传输的问题，安全可靠的传输协议有 tcp，希望快速传输的协议有 udp
- 会话层：解决两个应用之间如何建立与保持会话的问题
- 表示层：解决数据的加密编码压缩等问题
- 应用层：解决两个应用进程之间如何交互数据的问题，比如 http、ftp、websocket

## 状态码

- 200`OK` 请求成功
- 201`Created` 请求成功并处理完成
- 202`Accepted` 请求成功但没有处理
- 204`No Content` 请求成功但没有实体内容返回
- 206`Partial Content` 请求了部分资源
- 301`Moved Permanently` 永久重定向（1.0 标准，重定向时可变更请求方式）
- 302`Found` 临时重定向（1.0 标准，重定向时可变更请求方式）
- 303`See Other` 大多数的浏览器处理 302 响应时的方式恰恰就是上述规范要求客户端处理 303 响应时应当做的，所以 303 基本用的很少，一般用 302
- 304`Not Modified` 资源未修改
- 305`Use Proxy` 请求必须通过代理
- 307`Temporary Redirect` 临时重定向 （1.1 标准，重定向请求方式不可变）
- 308`Permanent Redirect` 永久重定向 （1.1 标准，重定向请求方式不可变）
- 400`Bad Request` 请求参数有误
- 401`Unauthorized` 请求需要验证用户身份（认证）
- 403`Forbidden` 请求被理解但拒绝执行（认证通过但没有权限访问资源）
- 404`Not Found` 请求失败，未找到合适资源
- 415`Unsupported Media Type` 不支持媒体类型，Content-Type 设置不对或不支持
- 500`Internal Server Error` 服务器未知错误
- 501`Not Implemented` 请求方式不被支持，无法完成请求
- 502`Bad Gateway` 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到错误的响应。
- 503`Service Unavailable` 当前服务器维护或过载，无法处理请求
- 504`Gateway Time-out` 网关或代理服务器未及时得到响应

!> [HTTP 常用状态码详解](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

## HTTPS 工作原理

- HTTPS 协议分为三个阶段：TCP 三次握手、TLS 四次握手（非对称加密）、加密通信
- 首先通过三次握手建立连接，客户端发送 SYN 包，服务器响应 ACK 包并进入半连接状态，待客户端响应 ACK 响应后进入全连接状态
- 连接建立后开始 TLS 四次握手
  - 第一次握手：客户端发送一个`客户端随机数`、支持的`加密套件`给服务器
  - 第二次握手：服务器响应客户端一个`服务器随机数`、要使用的`加密套件`，以及 CA 机构颁发的`数字证书`
  - 第三次握手：客户端拿到证书后，通过本地内置的 CA 公钥，验证合法性以及取出`服务器公钥`，通过`服务器公钥`加密`第三个随机数`发送给服务器
  - 第四次握手：服务器通过`服务器私钥`进行解密得到`第三个随机数`，通过前面三个随机数生成`会话密钥`，后续通过这个`会话密钥`与客户端进行对称加密通信

## HTTP 各版本区别

- 0.9
  - 只有简单的 get 请求，传输没有请求体/响应体，只能传输一些普通的文字文章
- 1.0
  - 增加 post、put、delete 等请求方式
  - 增加了字符集、压缩、加密等功能
    - `expires` 服务器绝对时间
    - `last-modified` 资源的最后修改时间 精确到秒
  - 可以传输图片、文件等其他格式
  - 每次 http 请求都需要建立 tcp 连接和释放连接
- 1.1
  - 增加缓存字段
    - `cache-control` 缓存控制
    - `e-tag` 资源标识符
  - 增加 `connection: keep-alive` 属性，开启 tcp 长连接，不需要每次 http 请求都重新建立连接，提高传输效率
  - 增加 `host` 字段支持一个物理机多个`虚拟机`的场景
    - host 字段表示请求的目标服务器的主机名和端口
  - `pipeline` 管道技术，支持并行发送，但需要顺序等待响应（浏览器默认不开启）（不能彻底解决队头拥塞问题）
  - 如果要实现并发请求，通过一个域名建立多个 tcp 连接（浏览器限制 6 个），如果想要更多的并发请求可以通过设置不同的域名
- 2.0
  - `头部压缩`，使用 `HPACK算法`（Compressed file archive 压缩文件存档），让客户端、服务器共同维护两个索引表，分别是`静态表`和`动态表`，请求时只需要发送索引就可以，减少发送的大小（静态表提前约定，动态表通过一次请求确定下来，对于动态表中存储的值还进行`哈夫曼编码`优化）（HPACK: Compressed file archive 压缩文件存档）
  - `二进制分帧`，通过`流标识`把一次的“请求-响应”标识为同一个流，不同的“请求-响应”标识为不同的流，不同的流互不影响可以乱序发送（相同流的帧按序发送，tcp 保证帧的有序）（流标识、帧类型、帧长度、标志位、数据体 payload）
    - `多路复用`（多个 http 报文在一个 tcp 通道中传输）
    - `优先级`
    - `服务器推送`
  - 透过二进制分帧和多路复用，只用一个 tcp 连接，就能并发地传输 http 请求，解决 http 队头阻塞问题（发生丢包重传的场景下，阻塞后面请求的处理）
- 3.0
  - 使用 QUIC（基于 UDP）传输协议代替 tcp 传输协议，解决 tcp 队头阻塞问题（QUIC 也是通过流的方式，在一个连接中，支持不同请求通过不同的流进行标识，不同流之间支持乱序发送且互不影响）

## http 报文格式

- http 报文分为请求报文和响应报文
- 请求报文包括请求行、请求头、请求体，请求行中包括请求方法、URL、http 版本，一般 get 请求的请求体为空，post 请求的请求体才有数据
- 响应报文包括状态行、响应头、响应体，状态行中包括 http 版本、状态码、状态信息
- 请求头和响应头中存的是多个以键值对形式存在的信息，包含的属性有关于`长连接`的 connection:keep-alive，还有`缓存`相关的 expires、date、cache-control、last-modified、etag，`安全`相关的 referrer ，用来判断来源 csrf 攻击，还有`跨域`相关的 origin、access-control-allow-origin 等等，还有跟`内容`相关的 content-type、content-length、content-encoding:gzip，跟`传输`有关的 transfer-encoding:chunked 分块传输，还有范围传输的 content-range 等等

## DDoS 攻击有哪些类型

- TCP SYN FLOOD (TCP 洪水攻击)
  - 利用 TCP 漏洞
  - 伪造 IP 发送海量请求连接中第一个握手的 SYN 包，不响应服务器 ACK 包
  - 让服务器存在大量的`半连接`数据包
- UDP FLOOD (UDP 洪水攻击)
  - 发送大量的 UDP 包，包括小包（64K）和大包（1500K）
- HTTP FLOOD (CC 攻击) Challenge Collapsar
  - 发送大量的 HTTP 请求，模拟网站访问者以耗尽资源

## DDoS 带来的影响

- 耗尽`带宽`、`CPU`资源

### 如何发现判断 DDoS

- 监控工具
  - ping
  - netstat

### 如何预防 DDoS

- 防火墙
- 流量过滤
- 使用 CDN
