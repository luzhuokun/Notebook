## git merge 和 git rebase 的区别

- 从最终的结果看，都是把`代码合并`到一起去；
- git merge 合并代码时会`产生`额外的`合并记录`；
- git rebase 合并就是变基，从共同的祖先记录开始，基于最新的 A 分支提交记录来重新合并 B 分支的提交记录；
- git rebase `不会产生`新的合并记录，会使项目历史更加的整洁，但在协作分支上`不建议`使用 git rebase，会对其他协作者产生影响；

## gitlab review

- 常见的 code review 有两种方式：本地方式和远程方式
- `本地方式`，通过把远程代码拉到本地合并进行 review
- `远程方式`，通过在 gitlab 平台上发起 merge request 进行 review

## git flow 规范

- 划分
  - master（生产分支）
    - 只做合并不做提交，合 release 分支和 bugfix 分支
  - release（预发布分支）
    - 从 develop 拉取，修复预发布问题后，同时合到 master 合 develop 分支
  - develop（公共开发分支）
    - 用于开发、集成测试，合并多个功能需求
  - feature（功能分支）
    - 从 develop 拉取分支
  - hotfix（bug 修复分支）
    - 从 master 分支拉取，修复完合到 master 和 develop 分支中
- 打 tag 好处
  - 方便快速`回滚`指定版本
  - 方便`测试`时构建指定版本
- 工作流程
  - 根据功能需求，从 develop 分支拉取 feature 分支
  - 开发完成，合并到 develop 分支进行集成测试
  - 从 develop 中拉取 release 分支进行预发布测试
  - 最终合并到 master 分支，打 tag

## npm yarn pnpm 区别

- npm yarn 和 pnpm 都是包管理工具，用于`管理` node_modules 中依赖包的加载和卸载
- npm
  - 在 npm3.0 之前采用`嵌套模式`（nest mode）进行包管理，存在依赖地狱、重复安装问题
    - `依赖地狱`
      - 早期会把依赖包都安装在自己文件夹目录下的 node_modules，不断嵌套形成嵌套地狱
      - 解决：把依赖包拉平复用（但不能完全拉平，因为有同包不同版本的情况）
    - `重复安装`
      - 在同包不同版本的场景下，只会取了其中一个放在最外层的 node_modules 上（因为只提取了 A，B 被多个包使用），多个任然存在重复安装问题
      - 找包算法：先从自己内部的 node_modules 目录下找，然后再从外面一层找，采用递归的方式
  - 在 npm3.0 之后采用`平坦模式`（flat mode）管理，对相同版本的一个包进行提升，提升到 node_modules 的目录下进行复用，能减轻依赖地狱和重复安装的问题，但不能彻底解决，还引入了新的问题：幽灵依赖
    - `幽灵依赖`
      - 没有在 package.json 上声明的包，在某些依赖包安装时顺带下载下来了，并且直接在项目中使用了
- yarn
  - 支持`并行下载`模块包，比 npm 逐个下载效率高
  - `增加 lock 文件`，锁定依赖包版本，保证开发环境与生产环境的一致性
  - 支持全局缓存，复用依赖包下载
- pnpm
  - 通过两方面来解决重复安装和幽灵依赖的问题
  - 第一个是把依赖包统一安装到 pnpm 全局管理的 `store 目录`下，然后通过`软硬链接`来对项目的依赖包进行管理，有效解决重复安装问题，在跨应用中使用也有优势
    - 通过`硬链接`让.pnpm 目录下模块包链接到 store 目录下的依赖包
    - 通过`软链接`（符号链接）的方式映射回上层的 node_module 目录下
  - 第二个是把模块包的嵌套结构隐藏在 node_module 中的.pnpm 目录下，只对 package.json 上定义的依赖才通过软链接映射到外层的 node_module 目录下解决幽灵依赖问题
  - 好处：使用 pnpm 可以有效节省磁盘空间、避免幽灵依赖

[浅析 node_modules 如何解决依赖地狱问题](https://www.cnblogs.com/goloving/p/16204049.html)

### pnpm 命令

- `pnpm i 包名 -S/-D -w`
  - -w 全局安装
- `pnpm i 包名 -S/-D`
  - 直接切换到子包的目录进行安装
- `pnpm i 包名 -S/-D --filter 子包的名称`
  - --filter 是用来指定子包
- `pnpm i 子包1 --filter 子包2`
  - 通过这个命令，可以在子包 2 中引用子包 1

[pnpm run](https://pnpm.io/zh/cli/run)

## 软链接和硬链接的区别

- 软链接和硬链接都是用来`访问同一个文件`
- 当`删除源文件`时，软链接会失效，硬链接不会
- 软链接像`快捷方式`，是一个指向源文件索引节点（inode）的引用，软链接不仅能链接文件还能链接目录
- 硬链接像一个`备份`，是指向同一个索引节点的指针，会把源文件的引用计数增加，当引用计数为 0 时代表文件被删除（数据其实还在，如果想真正地删除文件，应该反复地进行文件内容的覆盖删除等操作）
